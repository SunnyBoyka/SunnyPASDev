var dfq_pop_overs = {
    pop_overs:
        [
            {
                "id": "#td_identified_pop_over", "content": `<div id='identified_popup'><b>Identified</b> The requirement is captured (Statement) and identified (Identifier). This value shall also be set for a requirement that have been modified (#Statement or other attributes) in order to manage evolutions</div>
                                                                 <div id='draft_popup'><b>Draft</b> Requirement identification and text on-going</div>`,
                "sub_pop_up_legacy": "#draft_popup", "sub_pop_up_non_legacy": "#identified_popup"
            },
            { "id": "#td_defined_pop_over", "content": "the requirement is characterized and allocated / assigned" },
            {
                "id": "#td_coown_pop_over", "content": `<div id='committed_popup'><b>Committed : </b>the designated Receiver has understood the requirement and accepts the requirement characterization and allocation/assignment. Both requirement Provider and Receiver have an agreement on the requirement.</div>
                                                        <div id='owned_popup'><b>Owned : </b>Set by the Provider of the requirement with Receiver’s agreement. The designated Receiver has understood the requirement and accepts the requirement characterization and its allocation/assignment. Both requirement Provider and Receiver have an agreement on the requirement, after proofreading cycles or design reviews</div>`,
                "sub_pop_up_legacy": "#owned_popup", "sub_pop_up_non_legacy": "#committed_popup"
            },
            { "id": "#td_covered_pop_over", "content": "the requirement receiver has identified the requirement identifier(s) in its specifications covering the parent requirements and has set the covering links." },
            { "id": "#td_obsolete_pop_over", "content": "the requirement is no more Applicable (once a requirement has been characterized, it shall not be deleted but declared as obsolete)" },
            { "id": "#td_rejected_pop_over", "content": "Set by the receiver of the requirement. The allocated requirement is partially or totally misunderstood; the requirement requires more clarification or the designated receiver in charge of requirement doesn’t agree with the requirement allocation/assignment." },
            { "id": "#td_characterized_pop_over", "content": "Set by the Provider of the requirement on which characterization attributes are set, but which is considered not mature enough for analysis by the “allocated/assigned” user. A requirement “Characterized” should not be reviewed/commented on by the receivers of the requirement." },
            { "id": "#td_assigned_pop_over", "content": "Set by the provider of the requirement for a requirement characterized and allocated / assigned when the requirement is considered sufficiently mature to be reviewed / commented by the receiver(s) of requirement." },
            { "id": "#td_analyzed_pop_over", "content": "For contractual requirement only (included in PRD or SyUN/SyRB), in order to study the compliance. The compliance can be set to Compliant, NC (Not Compliant), GAP: when the compliance is set to “Compliant”, “GAP” or “NC”, the Requirement lifecycle status becomes “Analyzed”. “Analyzed” is a terminal state for NC, and can be transitory for GAP or compliant to the “Traced_by_Implem” when the traceability is fully set by the receiver" },
            { "id": "#td_traced_by_implementation_pop_over", "content": "Set by the Requirement(s) Receiver, stating that the upper requirement is fully covered by the covering Requirement(s). All the covering requirements are at least “Owned” to ensure stability. This implies that the covered requirement and covering requirements are delivered. In case of relevant multi-allocation/assignment, the status is the synthesis of all receivers information (it can be done by some automation)" },
            { "id": "#td_covered_by_implementation_pop_over", "content": "Set by the 2nd Sight (can be the Requirement Provider, or the V&C Verifier or a Peer), confirming that the requirement is fully covered by the receiver(s)." },
            { "id": "#td_traced_by_mean_of_proof_pop_over", "content": "Set by the Requirement Verifier (V&C Verifier) when there is an existing Mean of Proof (MoP) identified, according to validation method (MoP Class) defined in the RVT – for e.g. for a Validation Method is set to “Test”, when the requirement is covered by an existing test procedure/Test Case. Note: for requirement with no formal MoP available (concern mainly non-technical Requirements) the transition “Covered_by_Implem” goes directly to “Demonstrated” status." },
            { "id": "#td_covered_by_mean_of_proof_pop_over", "content": "Set by the Requirement Verifier when the Mean of Proof (MoP) according to validation method defined in the RVT is verified OK – for e.g. for “Test”, when the requirement is covered by an existing verified test procedure/Test case (for e.g. RTD VR available (Requirement Test Description Verification report)). Note: for requirement with no formal MoP available (concern mainly non-technical Requirements) the transition “Covered_by_Implem” goes directly to “Demonstrated” state." },
            { "id": "#td_demonstrated_pop_over", "content": "Set by the Requirement Verifier. Verification (consistent and complete implementation of requirements) and Validation of requirement is achieved and result is “Pass”." },
            { "id": "#td_time_of_movement_pop_over", "content": "" },
            { "id": "#td_dfq_date_pop_over", "content": "It's the Date when DFQ is completed" },
            { "id": "#span_segment_pop_over", "content": "If same project/program has different DFQ's & differentiated here by stating for example, LoT1, Phase 1 etc.," },
            { "id": "#span_ct_gp_code_pop_over", "content": "Code assigned for Financial transaction <ul> <li>CTxxx for Projects</li><li>PGxxx for Programs</li> </ul>" },
            { "id": "#span_leading_unit_pop_over", "content": "Region to which this Project/Program Finance is being monitored." },
            { "id": "#span_cluster_pop_over", "content": "Displays Region/Cluster working for this project. If multiple participating units name of activity to be properly updated to data entry for respective clusters." },
            { "id": "#span_breakdown_level_pop_over", "content": "Displays the Levelx of reporting - For example, <ul><li>Customer requirement then L0</li><li>System level requirement L1</li><li>Subsystem Level requirement then L2</li><li>Sw or component level requirement then L3</li></ul>" },
            { "id": "#span_rm_name_pop_over", "content": "Displays RM responsible" },
            { "id": "#span_quality_in_charge_pop_over", "content": "Displays Quality responsible" },
            { "id": "#span_pc_incharge_pop_over", "content": "Displays PC responsible" },
            { "id": "#td_empty_pop_over", "content": ""}
        ]
}
var dfq_base = {
    __proto__: dfq_pop_overs,
    column_key_mapping_sgr: { identified: "#sgr_identified", defined: "#sgr_defined", coown: "#sgr_coown", covered: "#sgr_covered", characterized: "#sgr_characterized", assigned: "#sgr_assigned", analyzed: "#sgr_analyzed", traced_by_impl: "#sgr_traced_by_impl", covered_by_impl: "#sgr_covered_by_impl", traced_by_mop: "#sgr_traced_by_mop", covered_by_mop: "#sgr_covered_by_mop", obsolete: "#sgr_obsolete", rejected: "#sgr_rejected", empty: "#sgr_empty", demonstrated: "#sgr_demonstrated", dfq_date: "#sgr_dfq_date", insert_update_time: "#sgr_insert_update_time" },
    column_key_mapping_pgr: { identified: "#pgr_identified", defined: "#pgr_defined", coown: "#pgr_coown", covered: "#pgr_covered", characterized: "#pgr_characterized", assigned: "#pgr_assigned", analyzed: "#pgr_analyzed", traced_by_impl: "#pgr_traced_by_impl", covered_by_impl: "#pgr_covered_by_impl", traced_by_mop: "#pgr_traced_by_mop", covered_by_mop: "#pgr_covered_by_mop", obsolete: "#pgr_obsolete", rejected: "#pgr_rejected", empty: "#pgr_empty", demonstrated: "#pgr_demonstrated", dfq_date: "#pgr_dfq_date", insert_update_time: "#pgr_insert_update_time" },
    column_key_mapping_cgr_i: { identified: "#cgr-i_identified", defined: "#cgr-i_defined", coown: "#cgr-i_coown", covered: "#cgr-i_covered", characterized: "#cgr-i_characterized", assigned: "#cgr-i_assigned", analyzed: "#cgr-i_analyzed", traced_by_impl: "#cgr-i_traced_by_impl", covered_by_impl: "#cgr-i_covered_by_impl", traced_by_mop: "#cgr-i_traced_by_mop", covered_by_mop: "#cgr-i_covered_by_mop", obsolete: "#cgr-i_obsolete", empty: "#cgr-i_empty", rejected: "#cgr-i_rejected", demonstrated: "#cgr-i_demonstrated", dfq_date: "#cgr-i_dfq_date", insert_update_time: "#cgr-i_insert_update_time" },
    column_key_mapping_cgr_a: { identified: "#cgr-a_identified", defined: "#cgr-a_defined", coown: "#cgr-a_coown", covered: "#cgr-a_covered", characterized: "#cgr-a_characterized", assigned: "#cgr-a_assigned", analyzed: "#cgr-a_analyzed", traced_by_impl: "#cgr-a_traced_by_impl", covered_by_impl: "#cgr-a_covered_by_impl", traced_by_mop: "#cgr-a_traced_by_mop", covered_by_mop: "#cgr-a_covered_by_mop", obsolete: "#cgr-a_obsolete", empty: "#cgr-a_empty", rejected: "#cgr-a_rejected", demonstrated: "#cgr-a_demonstrated", dfq_date: "#cgr-a_dfq_date", insert_update_time: "#cgr-a_insert_update_time" },
    column_key_mapping_fei: { identified: "#fei_identified", defined: "#fei_defined", coown: "#fei_coown", covered: "#fei_covered", characterized: "#fei_characterized", assigned: "#fei_assigned", analyzed: "#fei_analyzed", traced_by_impl: "#fei_traced_by_impl", covered_by_impl: "#fei_covered_by_impl", traced_by_mop: "#fei_traced_by_mop", covered_by_mop: "#fei_covered_by_mop", obsolete: "#fei_obsolete", rejected: "#fei_rejected", empty: "#fei_empty", demonstrated: "#fei_demonstrated", dfq_date: "#fei_dfq_date", insert_update_time: "#fei_insert_update_time" },
    column_key_mapping_vgr: { identified: "#vgr_identified", defined: "#vgr_defined", coown: "#vgr_coown", covered: "#vgr_covered", characterized: "#vgr_characterized", assigned: "#vgr_assigned", analyzed: "#vgr_analyzed", traced_by_impl: "#vgr_traced_by_impl", covered_by_impl: "#vgr_covered_by_impl", traced_by_mop: "#vgr_traced_by_mop", covered_by_mop: "#vgr_covered_by_mop", obsolete: "#vgr_obsolete", rejected: "#vgr_rejected", empty: "#vgr_empty", demonstrated: "#vgr_demonstrated", dfq_date: "#vgr_dfq_date", insert_update_time: "#vgr_insert_update_time" },
    column_key_mapping_iqa: { identified: "#iqa_identified", defined: "#iqa_defined", coown: "#iqa_coown", covered: "#iqa_covered", characterized: "#iqa_characterized", assigned: "#iqa_assigned", analyzed: "#iqa_analyzed", traced_by_impl: "#iqa_traced_by_impl", covered_by_impl: "#iqa_covered_by_impl", traced_by_mop: "#iqa_traced_by_mop", covered_by_mop: "#iqa_covered_by_mop", obsolete: "#iqa_obsolete", rejected: "#iqa_rejected", empty: "#iqa_empty", demonstrated: "#iqa_demonstrated", dfq_date: "#iqa_dfq_date", insert_update_time: "#iqa_insert_update_time" },
    column_key_mapping_fqa: { identified: "#fqa_identified", defined: "#fqa_defined", coown: "#fqa_coown", covered: "#fqa_covered", characterized: "#fqa_characterized", assigned: "#fqa_assigned", analyzed: "#fqa_analyzed", traced_by_impl: "#fqa_traced_by_impl", covered_by_impl: "#fqa_covered_by_impl", traced_by_mop: "#fqa_traced_by_mop", covered_by_mop: "#fqa_covered_by_mop", obsolete: "#fqa_obsolete", rejected: "#fqa_rejected", empty: "#fqa_empty", demonstrated: "#fqa_demonstrated", dfq_date: "#fqa_dfq_date", insert_update_time: "#fqa_insert_update_time" },
    all_gates_column_key_mappings: null,
}